
# 索引数据结构：二叉树、红黑树、hash、B+树
### 为什么不用二叉树
- 因为如果是数据是顺序递增插入的话，用二叉树就会变成个链表。
### 为什么不用红黑树
- 红黑树其实也是个二叉树，如果数据量上百千万，树的高度会太高
### 为什么不用B树，而用B+树
- B树就是一个节点放很多个索引和data(索引所在行的磁盘文件地址)，索引元素之间会存储下一层的节点的地址。
- B+树其实是在B树的基础上做了优化，第一个优化就是非叶子节点不存储data，只存储冗余索引，叶子节点包含所有索引；第二个优化就是叶子节点之间有双向的指针，可以用于范围查询。
- B+树查询性能好就是因为，从B+树根节点开始，会先low一个节点到内存，这个是比较耗时的，然后在内存里面做数据比对找到要找的数据的下一层的节点地址，这个不是特别耗时。而红黑树一个索引就一个节点，把节点的数据low到内存是特别耗时的。mysql三层的树高就可以存储两千多万的数据。而且mysql可能会把根节点常驻到内存里面，
- 为什么要把data都放到叶子节点，就是因为树的高度是由非叶子节点能放多少个索引决定的，一个节点存越多索引，树的高度就越低，而且节点越少，也可以减少把节点low到内存的时间。
- 为什么要加个双向指针？方便范围查询

```text
比如索引是bigint，占8byte，一个地址是6Byte，那么一个非叶子节点可以存储1170个元素，而叶子节点存的data一般不超过1k，那一个叶子节点就可以存储16个数据，那三层的树，就可以存储1170*1170*16=两千多万
```
# myisam和innodb、聚集索引、聚簇索引、稀疏索引是什么
### myisam
- 表的底层存储是frm（表结构信息）、myd（data）、myi（index）三个文件，myd存的是数据，myi存的是索引的B+树。索引和数据是分开存储，这种叫非聚簇索引。索引的B+树的叶子节点的data存的是数据的某一个行的地址。

### innodb
- 表的底层存储是frm（表结构信息）、ibd（data+index）三个文件。ibd只会有一个聚簇索引，就是数据和索引在一起的B+树，数据存在B+树的叶子节点。但是普通索引其实还是非聚簇索引，叶子节点的data存的是主键值，存主键的好处是保证数据一致性和节省存储空间。

# 为什么推荐使用整型自增索引做主键
- 因为如果是字符串，索引查找的就得对字符串索引的每个字符一一比较，非常耗时。
- 如果不是自增的话，往B+树节点的中间位置插入一个数的时候，可能会导致节点分裂、或者做个树平衡。如果是自增的话，就会再往后面开一个节点，不影响原来的节点。

# 联合索引底层数据结构，mysql最左前缀优化原理
- 先按照第一个字段排好序，再按照第二个字段排好序，再按照第三个字段排好序
- mysql最左前缀优化原理就是因为跳过第一个字段，第二个字段是无序的，所以没办法用，只能整个表查询。

# explain详解与使用
- partitions：分区
- filtered：rows*filtered/100估算出将要和explain中前一个表进行连接的行数（前一个表指id值比当前表id值小的表）
- id：有几个select就有几个id，id越大执行优先级越高，id相同则从上往下执行，id为null则最后执行
- select type：表示对应行是简单还是复杂的查询。
  - primary：最外层的select；
  - subquery：select中的子查询；
  - derived：from中的子查询；mysql会把结果放在一个临时表中，也叫派生表
  - union：union后面的select
- type：mysql如何查找表中的行，从好到差：system>const>req_ref>ref>range>index>all，一般达到range以上，最好达到ref
  - null：在优化阶段分解查询语句，在执行阶段不用遍历表或索引就能直接确定。（比如select min(id) from 表） 
  - const： where后面的字段，用到了primary或者唯一索引，只有一条匹配数据。system是const的特例，表里只有一条数据。
  - req_ref: 被关联表的on的过滤字段是primary或者唯一索引（A left join B，B是被关联表，A是主表）
  - ref：就是用到了索引，筛选出来的条件会有多条。对应简单查询，where后面的字段用的是普通索引；对应关联查询，主表的on过滤字段只命中唯一索引的部分字段。
  - range：用到了索引，但是是范围查找的。用到了in，between，>,<
  - index：扫描整个二级索引拿到结果。（比如select id,name from 表，name有二级索引）
  - all：扫描整个聚簇索引
- possible key：可能使用哪些索引来查询。
- key：最终用到的索引
- key_len:在索引里使用的字节数。可以算出索引用了哪些列。（char(n)=n字节长度，varchar（utf-8 n）=3n+2字节长度 （2用来存字符串长度），int=4字节长度） 
- ref：在key列记录的索引中，表查找值所用到的列或常量。比如：const（常量）、字段名
- rows：估计要读取或检测的行数
- extra：
  - using index：使用覆盖索引，就是包括where或者select后面的字段都可以直接从索引中获取
  - using where：用了where，并且where或者select后面的列未被索引覆盖
  - using index condition：查询的列不完全被索引覆盖，比如where后面是范围查询某个索引字段
  - using temporary：需要创建一张临时表来处理查询，比如遇到没有索引的数据（select distinct name from 表）

# 常见索引优化原则
- 全值匹配
- 最左前缀法则
- 不在索引列上做函数、计算、类型转换处理
- 所有a列是范围，b列会失效
- 尽量使用覆盖所有，就是查询列在索引列中，减少select *
- 使用!=会导致全表扫描
- is null 或者is not null一般情况走不了索引
- like "%aa"，会导致索引失效
- 少用or或者in，不一定会走索引
- 范围查询不一样会走索引
# 
